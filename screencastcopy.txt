Hi my name is Nathan Hopkins and I'm the principle owner of Hopsoft LLC.
I'm here to introduce the Fig Ruby Gem and Rails plugin.

Fig is a simple yet powerful tool to manage configuration settings for Ruby applications.

I started to notice that a lot of my Ruby applications had settings and values throughout the code that really
belonged in a config file.  My first approach was to put these values into a Hash that was
globally available to my application.  This works and is a good first step, but I wanted something
a little more elegant and powerful.

Fig is hosted on github and is available as a both a Gem and as a Rails plugin.

Before we dig in to how to use Fig, let me highlight some of the key features it provides.
    * Fig uses YAML files to hold config settings
	* it supports having multiple configuration files
	* it provides dynamic updating and re-loading of settings in these files, in a thread-safe way
	* it simplifies config setting access by exposing your settings via Hashes, OpenStructs, and method calls.
	* it supports and encourages reuse of redundant settings to help apply DRY principles to your configurations.
	* all access to settings is thread-safe, so you won't get a dirty read even when some other thread is reloading the config files.

So... lets jump right in.
Initially I'll be showing you how to install Fig as a Ruby Gem.  At the end of the screencast, 
I will demonstrate how to install Fig as a Rails plugin.

To get started lets create a rails application called "fig_sample".

  >rails fig_sample
  >cd fig_sample

Once that is complete, we need to edit the environment.rb file in the config directory and setup our gem dependeny for Fig.

  >nano config/environment.rb

Since Fig is hosted on github, the name is "hopsoft-fig" and the lib is "hopsoft/lib".

  config.gem 'hopsoft-fig', :lib => 'hopsoft/fig'

Now that we have our gem dependency setup, we need to run "rake gems:install" to ensure that Fig installed.

  >rake gems:install

Once Fig is installed we need to create a YAML file that will serve as our first config file.
For the purpose of this tutorial, we will name the first one "sample.yml".
Lets go ahead and edit this file and add some simple settings.

  >nano config/sample.yml

Lets add a few settings.

  author: Nathan Hopkins
  company: Hopsoft LLC
  message: Fig is the smart configuration tool for Ruby apps.

Now we need to add a couple of lines to our environment.rb.
First we need to require Fig in our application.
Next we need to load our "sample.yml" file into a Fig object.

  >nano config/environment.rb
  
  require 'hopsoft/fig'
  SAMPLE = Hopsoft::Fig.new(RAILS_ROOT + '/config/sample.yml')

And thats pretty much it.  We are now ready to use our Fig object.

Lets start a console session and see how we can interact with it.

  >script/console
  
We can have a look at the YAML which is simply a Hash that contains all of the settings.

  >SAMPLE.yaml
  >SAMPLE.yaml['author']

We can access the "settings" as an OpenStruct which gives us a little cleaner way of interacting with the values via dot-notation.

  >SAMPLE.settings
  >SAMPLE.settings.author

And finally we can access the our settings with a method call to "get_setting".

  >SAMPLE.get_setting('author')

"get_setting" is the preferred way of accessing values from Fig for a couple of reasons.
First, it performs better than the "settings" and "yaml" properties because both the "settings" and "yaml" attributes actually clone the settings each time.
Second, its safer.  "get_setting will return a nil if the setting you ask for doesn't exist.

  >SAMPLE.get_setting('some.missing.setting')

Both the settings and yaml attributes will raise an error when a setting doesn't exist.

  >SAMPLE.yaml['some']['missing']['setting']
  >SAMLE.settings.some.missing.setting

This makes "get_setting" well suited to meta programming against settings that may not exist.

Ok.  Now I'd like to showcase how reuse is applied in a Fig file.
Lets get back in and edit the "sample.yml" file.

  >exit
  >nano config/sample.yml

Lets change the message to, 

  message: Fig is the smart configuration tool for Ruby apps, and was written by {fig:author} of {fig:company}.

Basically what is happening here is that any text wrapped inside of the curly braces and prfixed with "fig" will attempt 
to pull the value from elsewhere in the config file. 

Lets see it in action.
I'll bring the console back up and we can have a look at the "message".

  >script/console
  >SAMPLE.get_setting('message')

Very nice... especially if I need to use those values throughout my config file as it grows,  
keeping things DRY even in the config file.

But what about more complex nested config settings.  
Well, lets go add some.

  >exit
  >nano config/sample.yml

Lets add something like. 

  services:
    google:
      api_key: 12345
      maps: http://maps.google.com/maps?key={fig:api_key}
      charts: http://chart.apis.google.com?key={fig:api_key}
 
 I know these settings are somewhat contrived but I think you get the idea of what is possible.
 
 Now lets go have a look at how to access these settings with Fig.
 
   >script/console
 
 The YAML approach is somewhat verbose and ugly, but workable.  
  
  >SAMPLE.yaml['services']['google']['maps']
  
 Using the settings attribute is quite a bit cleaner. 
 
   >SAMPLE.yaml.services.google.maps
 
 But using "get_setting" is faster, safer, and almost as clean. 
 
   >SAMPLE.get_setting('services.google.maps')
   >SAMPLE.get_setting('services.google.api_key')
 
 This is great, but what if we need to change one of the settings after the application is already running?
 Lets see how we might do this.  
 I'll launch a new console window to make the changes so we can leave the current console environment in tact.
 
   windows > run > cygwin
   >cd /work/fig_sample
   >nano config/sample.yml
 
 Ok... lets say we needed to update our api_key for Google.  
 
   api_key: abcde
   
 I'll save that change and drop back over to our running console.
 
   >SAMPLE.get_setting('services.google.api_key')
 
 Notice that only the file has changed, not the value stored in memory.
 Lets reload and see what happens.
 
   >SAMPLE.load
   >SAMPLE.get_setting('services.google.api_key')
   
 Ah just what you might expect.  The new value is now reflected.
 Fig is threadsafe which means its safe to reload even when multiple threads may be accessing the Fig settings.
 Pretty nice. 
 
The last thing I want to showcase is the use of multiple config files.
Lets make a copy of our sample config file so we can segment the services configuration into its own file.
 
   >exit
   >cp sample.yml services.yml
 
Ok now, lets edit both files.

  >nano config/sample.yml
  >nano config/services.yml
  
And finally lets edit the environment.rb file and add some code to load up the services.yml file.

  >nano config/environment.rb
  
  SAMPLE = Hopsoft::Fig.new(RAILS_ROOT + '/config/sample.yml')
  
Lets bring up the console session again and test this out.
  
  >script/console
  >SAMPLE.yaml
  >SERVICES.settings  
   
Ands it just what you might expect.
 
Oh yeah, I almost forgot.  Lets rework this to use a Rails plugin rather than a Gem dependency.
First lets uninstall the Gem.
 
   >gem uninstall hopsoft-fig
   
Next we need to install Fig as a plugin.
 
   >script/plugin install http://github.com/hopsoft/fig.git
   
Now we need to remove the "require" line from environment.rb.  

  >nano config/environment.rb

Everything else remains the same.
Lets go test this out in a console session.
 
   >script/console
   >SAMPLE.yaml
   >SERVICES.settings
   
That just about wraps up this screencast.  I hope you find some good uses for Fig.
Please send any questions or comments to me on github.
Thanks for watching.